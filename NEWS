v0.2.2
    * optimization: optimized aligned pointer computation for strictly
        aligned types

v0.2.1
    * bug fix: specialized UNPARSE-TYPE on strictly aligned types

v0.2.0
    * new feature: Proxy types. Can be defined with DEFINE-PROXY-TYPE.
        Proxy types behave just the same as their proxied types,
        until you specialize one of the core generics on them.
        Proxied type of proxy type can be obtained by PROXIED-TYPE function.
        MAKE-INSTANCE's initarg for proxied type of proxy type is :TYPE
    * new feature: Type predicates.
        ** PRIMITIVE-TYPE-P
        ** IMMEDIATE-TYPE-P
        ** AGGREGATE-TYPE-P
        ** PROXY-TYPE-P
    * new feature: New core generics.
        ** COMPUTE-SLOT-OFFSET computes the offset of aggregate type's slot.
            For now it is specialized only on structure types, but this may
            change in the future.
        ** EXPAND-COMPUTE-SLOT-OFFSET is compile-time analogue of
            COMPUTE-SLOT-OFFSET and can be specialized
            for optimization purposes
    * enchancement: OFFSETOF and it's compiler macro now rely on
        COMPUTE-SLOT-OFFSET and EXPAND-COMPUTE-SLOT-OFFSET
    * new feature: Strictly aligned types. This kind of types can be
        represented by ALIGNED typespec. Syntax: (ALIGNED alignment type)
        Values of strictly aligned types are always allocated on
        boundaries that comply certain alignment.

v0.1.6
    * new feature: new options in DEFINE-IMMEDIATE-TYPE and
        DEFINE-AGGREGATE-TYPE macros. Like most other options, they are just
        shortcuts for defining methods of appropriate generic functions.
        ** :ALLOCATOR defines method of ALLOCATE-VALUE
        ** :DEALLOCATOR - FREE-VALUE
        ** :ALLOCATOR-EXPANSION - EXPAND-ALLOCATE-VALUE
        ** :DEALLOCATOR-EXPANSION - EXPAND-FREE-VALUE
    * optimization: EXPAND-ALLOCATE-VALUE and EXPAND-FREE-VALUE have been
        specialized on built-in types

v0.1.5
    * bug fix: Primitive types' EXPAND-PROTOTYPE could result in value
        that lisp compilers are unable to dump into fasls
    * bug fix: Primitive types' EXPAND-FREE-VALUE always returned NIL
    * bug fix: Invalid initarg to named enum type's constructor
    * bug fix: Some lisp implementations (e.g. clisp) doesn't allow
        function names to be symbols w/o package (well, not exactly
        disallow, but in this case that functions names and hence functions
        are simply lost after the compilation stage)

v0.1.4
    * CLEANUP-VALUE and EXPAND-CLEANUP-VALUE are renamed to
        CLEAN-VALUE and EXPAND-CLEAN-VALUE
    * ALLOCATE-VALUE and FREE-VALUE are now generic functions
        ** ALLOCATE-VALUE allocates memory for value of specified type
            (but does not write the contents of the supplied value into it)
        ** FREE-VALUE frees allocated memory
            (but does NO CLEANUP! Use CLEAN-VALUE first)
        ** There are also EXPAND-ALLOCATE-VALUE and EXPAND-FREE-VALUE
    * new features: ALLOC, CLEAN, FREE and CLEAN-AND-FREE functions
        ** ALLOC allocates memory and writes contents of supplied value
            into it (if the value is supplied. Otherwise it writes contents
            of type's PROTOTYPE)
        ** CLEAN does memory cleanup for the specified type
            (frees internal pointers in structures, for expample)
            but does not free supplied pointer. It requires lisp-level value
            of that type to be supplied because memory blocks
            allocated for that type may be of(non-fixed) size that
            depends on that value.
        ** FREE frees memory allocated to specified type
        ** CLEAN-AND-FREE does exactly what you think.

v0.1.3
    * Updated TODO
    * new features: New pointer arithmetic functions:
        ** &p (predicate for pointer)
        ** &= (test for pointer address equality)
        ** && (gets pointer address)

v0.1.2
    * Function STRUCT-SLOT-OFFSET was renamed to OFFSETOF
        (syntax: OFFSETOF struct-type-name member-name)
    * new feature: New primitive types:
        CHAR-T, UCHAR-T, WCHAR-T and PTRDIFF-T
    * enchancement: Improved translation of CFFI's integral types into
        those of Common Lisp
    * bug fix: Base type of CHAR type is now UCHAR-T, not SBYTE, and
        that of WCHAR is now WCHAR-T, not USHORT
    * bug fix: SBYTE and UBYTE are now aliases
        for INT8 and UINT8 correspondingly

v0.1.1
    * TRIVIAL-FEATURES added to the list of dependencies
    * enchancement: New interfaces - WITH-VALUE and WITH-VALUES

v0.1.0
    * Initial release
